// Generated by CoffeeScript 1.7.1
(function() {
  var app, express, gameWon, http, inArray, io, loadGame, logger, mongo, mongoURI, port, updateGame, _ref, _ref1, _ref2;

  mongo = require('mongodb');

  express = require('express');

  app = express();

  http = require('http').Server(app);

  io = require('socket.io')(http);

  logger = require('morgan');

  mongoURI = (_ref = (_ref1 = process.env.MONGOLAB_URI) != null ? _ref1 : process.env.MONGOHQ_URL) != null ? _ref : 'mongodb://localhost/games';

  app.engine('jade', require('jade').__express);

  app.set('views', __dirname + '/views');

  app.use(logger());

  app.use('/s', express["static"](__dirname + '/static'));

  app.get('/', function(req, res) {
    return res.send('Home Page');
  });

  app.get('/:color(b|w)/:game', function(req, res) {
    var black, game;
    black = req.params['color'] === 'b';
    game = req.params['game'];
    return res.render('hello.jade', {
      game: game,
      black: black
    }, function(err, html) {
      if (err) {
        console.log(err);
      }
      return res.send(html);
    });
  });

  loadGame = function(gameName, callback) {
    return mongo.Db.connect(mongoURI, function(err, db) {
      return db.collection('games', function(err, collection) {
        return collection.find({
          name: gameName
        }).toArray(function(err, games) {
          if (games.length > 0) {
            return callback(games[0].status);
          } else {
            return collection.insert({
              name: gameName,
              status: {
                won: false,
                black: [],
                white: []
              }
            }, {
              safe: true
            }, function(er, res) {}, callback({
              won: false,
              black: [],
              white: []
            }));
          }
        });
      });
    });
  };

  updateGame = function(gameName, status) {
    return mongo.Db.connect(mongoURI, function(err, db) {
      return db.collection('games', function(er, collection) {
        return collection.update({
          name: gameName
        }, {
          $set: {
            status: status
          }
        }, {
          w: 1
        }, function(err) {});
      });
    });
  };

  io.on('connection', function(socket) {
    console.log('a user connected');
    socket.on('join', function(game) {
      socket.join(game);
      return loadGame(game, function(status) {
        var blackToMove, color, colors, loc, _i, _j, _len, _len1, _ref2;
        blackToMove = status['black'].length <= status['white'].length;
        colors;
        if (blackToMove) {
          colors = ['black', 'white'];
        } else {
          colors = ['white', 'black'];
        }
        for (_i = 0, _len = colors.length; _i < _len; _i++) {
          color = colors[_i];
          _ref2 = status[color];
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            loc = _ref2[_j];
            socket.emit('move', {
              game: game,
              color: color,
              x: loc.x,
              y: loc.y
            });
          }
        }
        if (status['won']) {
          return socket.emit('win', status['won']);
        }
      });
    });
    socket.on('move', function(msg) {
      return loadGame(msg.game, function(status) {
        var color, free, loc, turn, won, _fn, _i, _j, _len, _len1, _ref2, _ref3;
        won = status['won'];
        turn = status['black'].length <= status['white'].length;
        if (msg.color === 'white') {
          turn = !turn;
        }
        free = true;
        _ref2 = ['black', 'white'];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          color = _ref2[_i];
          _ref3 = status[color];
          _fn = function(loc, color) {
            if (loc.x === msg.x && loc.y === msg.y) {
              return free = false;
            }
          };
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            loc = _ref3[_j];
            _fn(loc, color);
          }
        }
        if (!won && turn && free) {
          status[msg.color].push({
            x: msg.x,
            y: msg.y
          });
          io.to(msg.game).emit('move', msg);
        }
        won = gameWon(status);
        if (won) {
          io.to(msg.game).emit('win', won);
          status['won'] = won;
        }
        return updateGame(msg.game, status);
      });
    });
    return socket.on('disconnect', function() {
      return console.log('user disconnected');
    });
  });

  inArray = function(array, value) {
    return array.indexOf(value) > -1;
  };

  gameWon = function(status) {
    var b, color, dir, dirs, j, last, len, loc, longest, placed, sign, stone, stones, w, _i, _j, _len, _len1, _ref2;
    b = status['black'];
    w = status['white'];
    if (!b.length) {
      return false;
    }
    last;
    stones;
    color;
    if (b.length <= w.length) {
      color = 'white';
      last = w[w.length - 1];
      stones = w.slice(0);
    } else {
      color = 'black';
      last = b[b.length - 1];
      stones = b.slice(0);
    }
    stones = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = stones.length; _i < _len; _i++) {
        stone = stones[_i];
        _results.push(JSON.stringify(stone));
      }
      return _results;
    })();
    dirs = [
      {
        x: 0,
        y: 1
      }, {
        x: 1,
        y: 0
      }, {
        x: 1,
        y: 1
      }, {
        x: -1,
        y: 1
      }
    ];
    longest = 1;
    for (_i = 0, _len = dirs.length; _i < _len; _i++) {
      dir = dirs[_i];
      len = 1;
      _ref2 = [-1, 1];
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        sign = _ref2[_j];
        j = 0;
        while (++j) {
          loc = {
            x: last.x + sign * j * dir.x,
            y: last.y + sign * j * dir.y
          };
          placed = inArray(stones, JSON.stringify(loc));
          if (!placed) {
            len += j - 1;
            break;
          }
        }
      }
      if (len > longest) {
        longest = len;
      }
    }
    if (longest >= 5) {
      return color;
    } else {
      return false;
    }
  };

  port = Number((_ref2 = process.env.PORT) != null ? _ref2 : 8888);

  http.listen(port, function() {
    return console.log("Listening on " + port);
  });

}).call(this);
